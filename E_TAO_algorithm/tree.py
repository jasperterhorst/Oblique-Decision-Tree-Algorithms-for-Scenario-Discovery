"""
tree.py

This module defines the core classes used to represent decision trees in the TAO algorithm.
It provides a standard representation for tree nodes, including the base class (TreeNode),
a decision node (DecisionNode) that uses oblique splits, a leaf node (LeafNode) that holds
a constant prediction, and a DecisionTree class encapsulating the overall tree structure.
These classes intend to serve as a common format for trees generated by various oblique
decision tree algorithms (e.g., OC1, CART-LC) and later optimized using TAO.

The module also includes helper methods for traversing and visualizing the tree.
"""

import numpy as np
import matplotlib.pyplot as plt


class TreeNode:
    """
    Base class for all tree nodes.
    """
    def __init__(self, node_id, depth=0):
        """
        Initialize a tree node.

        Args:
            node_id: An identifier for the node.
            depth (int): The depth of the node in the tree.
        """
        self.node_id = node_id
        self.depth = depth
        self.parent = None
        self.children = []  # Decision nodes are expected to have exactly two children.

    def is_leaf(self):
        """
        Determine if the node is a leaf.

        Returns:
            bool: True if the node has no children, False otherwise.
        """
        return len(self.children) == 0

    def add_child(self, child):
        """
        Add a child to this node and update the child's depth.

        Args:
            child: A TreeNode to add as a child.
        """
        child.parent = self
        child.depth = self.depth + 1
        self.children.append(child)

    def __repr__(self):
        return f"TreeNode(id={self.node_id}, depth={self.depth})"


class DecisionNode(TreeNode):
    """
    A decision node that uses an oblique split (i.e., a hyperplane) to decide whether
    to send an instance to its left or right child.
    """
    def __init__(self, node_id, weights=None, bias=0.0, depth=0):
        """
        Initialize a decision node.

        Args:
            node_id: An identifier for the node.
            weights (np.array): The weight vector defining the hyperplane.
            bias (float): The bias term.
            depth (int): The depth of the node in the tree.
        """
        super().__init__(node_id, depth)
        self.weights = weights if weights is not None else np.array([])
        self.bias = bias

    def decision(self, x):
        """
        Determine the branch for the given input.

        Args:
            x (np.array): Input feature vector.

        Returns:
            int: 1 if x should proceed to the right child; 0 if to the left.
        """
        return 1 if np.dot(x, self.weights) + self.bias >= 0 else 0

    def __repr__(self):
        return (f"DecisionNode(id={self.node_id}, depth={self.depth}, "
                f"weights={self.weights}, bias={self.bias})")


class LeafNode(TreeNode):
    """
    A leaf node that stores a constant prediction (e.g., a class label or regression value).
    """
    def __init__(self, node_id, prediction=None, depth=0):
        """
        Initialize a leaf node.

        Args:
            node_id: An identifier for the node.
            prediction: The prediction stored at the leaf.
            depth (int): The depth of the node in the tree.
        """
        super().__init__(node_id, depth)
        self.prediction = prediction

    def __repr__(self):
        return f"LeafNode(id={self.node_id}, depth={self.depth}, prediction={self.prediction})"


class DecisionTree:
    """
    A decision tree composed of TreeNodes. This structure serves as the basis for the TAO algorithm.
    """
    def __init__(self, root: TreeNode):
        """
        Initialize the decision tree.

        Args:
            root (TreeNode): The root node of the tree.
        """
        self.root = root

    def predict(self, x):
        """
        Traverse the tree from the root to a leaf to get a prediction.

        Assumes that for any decision node, children[0] is the left child and children[1] is the right.

        Args:
            x (np.array): Input feature vector.

        Returns:
            The prediction stored in the reached leaf node.
        """
        node = self.root
        while not node.is_leaf():
            if isinstance(node, DecisionNode):
                direction = node.decision(x)
                if len(node.children) < 2:
                    raise ValueError(f"DecisionNode {node.node_id} does not have two children.")
                node = node.children[direction]
            else:
                break
        if isinstance(node, LeafNode):
            return node.prediction
        return None

    def traverse(self, action=lambda node: print(node), node=None):
        """
        Recursively traverse the tree and apply a given action to each node.

        Args:
            action (function): A function that takes a node as input.
            node (TreeNode, optional): The starting node for the traversal. Defaults to the root.
        """
        if node is None:
            node = self.root
        action(node)
        for child in node.children:
            self.traverse(action, child)

    def _build_tree_str(self, node, indent=""):
        """
        Recursively build a string representation of the tree structure.

        Args:
            node (TreeNode): The node from which to build the string.
            indent (str): Indentation for the current level.

        Returns:
            str: A string representation of the subtree.
        """
        tree_str = indent + repr(node) + "\n"
        for child in node.children:
            tree_str += self._build_tree_str(child, indent + "    ")
        return tree_str

    def plot(self):
        """
        Generate a textual representation of the tree structure and display it using matplotlib.
        """
        fig, ax = plt.subplots(figsize=(8, 6))
        ax.axis("off")
        tree_str = self._build_tree_str(self.root)
        ax.text(0.05, 0.95, tree_str, fontsize=10, family="monospace",
                verticalalignment="top", transform=ax.transAxes)
        plt.show()
